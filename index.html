<html>
    <head>
        <title>Software Engineering Blog</title>

    </head>


    <body>
        <h1>HW0: Introduction</h1>

        <p> I was born in Charleston, South Carolina. However, I have also lived in Alabama and Virginia before moving back to 
            Charleston when in seventh grade. I remained in Charleston until I graduated high school from Fort Dorchester, 
            after which my parents moved to Georgia. I am now a junior and a computer science major at College of Charleston. My faith, family, friends, and my 
            dog, an eleven year old lab mix, are a few things that are important in my life. My current favorite movie is A Star is Born (the new version). I also enjoy going to the beach and going for
            bike rides, and I have recently taken up knitting over the past year. (In other words, I have knitted far too many scarves to live in a state with such hot and humid
            weather.) I am excited to further my knowledge of computer science in this software engineering course this semester and to see where my acquired
            knowledge will take me in my future CS career.
        </p>
        
        <h1>HW1: Chapter 1</h1>
        
        
        <p>
            <strong>1.3</strong>        
        </p>
        <p>
            Four important attributes that all professional software should possess include acceptability, dependability and security, efficiency, and maintainability. Other
            attributes that may sometimes be significant may include: 1. creativity in order to appeal to a specific client/user base depending on the purpose of the software,
            2. backward compatibility in order for users to be able to continue using the software with older versions of files and data, 3. being innovative in order to keep up and 
            compete with other rapidly advancing and changing technologies (for example, that of other competing companies), and 4. portability in order to provide users with
            increased mobility of software on any device or operating system they may prefer.
        </p>
        
        
        <p>
            <strong>1.8</strong>        
        </p>
        <p>
           In my opinion, professional engineers should be licensed in the same way as doctors or lawyers in terms of ethical practices. Because the vast majority of society depends daily on the work by software
            engineers, their work could have potential detrimental effects. For example, if a software engineer is developing software for a doctor's office, a level of respect
            and confidentiality should be given to the patients when the developer has access to personal information that may be used maliciously if placed into the wrong hands.
            Software developers have a great knowledge base that allows them to work in a wide variety of fields, which most other professions do not possess. Therefore, the 
            dependability and trustworthiness of software developers is vital to the workings of an ethical society.
            
        </p>
        
        
        <p>
            <strong>1.9</strong>        
        </p>
        <p>
            PUBLIC: When developing a website for a large company, a software engineer should not implement a virus into the site that would infect users' computers for the purpose of stealing
            personal information, such as passwords, bank account information, etc.
        </p>
        <p>
            CLIENT AND EMPLOYER: If a bug is discovered in an online shopping website by the software engineer, it is expected that the bug will be fixed out of interest for both
            the client and employer. For example, if the website calculates an incorrect amount of state tax owed by the user at checkout, this could negatively effect both the
            client and employer.
        </p>
        <p>
            PRODUCT: If the developer realizes he/she does not have the proper skill set to perform a certain task, he/she should admit this fact and allow a developer with the proper
            expertise to handle the task.
        </p>
        <p>
            JUDGMENT: When a software engineer recognizes a potential overlooked problem in a team's code/work, he/she should know when to speak up about the problem rather than
            knowingly allowing the problematic work to be implemented into practice.
        </p>
        <p>
            MANAGEMENT: A software engineer should give credit where credit is due for work that is not theirs. It is common for developers to use previously written code, but credit
            should be given to the original developer of that code when needed.
        </p>
        <p>
            PROFESSION: Software engineers should do their best to meet proposed deadlines to clients and should not knowingly withhold critical information needed by the client.
        </p>
        <p>
            COLLEAGUES: When a colleage asks for aid on a task they are struggling with, a supportive software engineer will be willing to give advice in a non-condescending manner.
        </p>
        <p>
            SELF: With an ever growing amount of technology, a software engineer should continue to take courses and study new technological advances and innovations in their field.
        </p>
        
        
        <p>            
            <strong>1.10</strong>        
        </p>
        <p>
            To help counter terrorism, many countries are planning or have developed computer systems that track large numbers of their citizens and their actions. Clearly, this
            has privacy implications. If a software engineer found that this interfered with their personal ethics, he/she would technically be required to speak out against this
            and possibly resign from their position. However, this remains a problem of personal choice, as it may be seen as both ethical and unethical, depending on the point
            of view. For example, some may view any invasion of privacy as unethical, despite the reasoning behind it. On the other hand, if the US were to use such technology
            against an enemy country during a time of war or under suspicion of malicious acts against the US, some may perceive such use of technology justifiable. In this example,
            some may even consider it it unethical to not use such technology against another country in order to protect the USA's own citizens. In matters such as this, the ethics
            of working on the development of this type of system becomes a matter of personal choice and specific situations.
        </p>
        
        
        <h1>HW2: Reflections on software engineering practices</h1>
        
        <p>
            All three of the assigned readings, in one way or another, discuss the development costs that accompany any software development process and the methods that can help reduce and/or increase these costs. “No Silver Bullet” highlights this fact by stating that “the cost of software has always been development cost, not replication cost” (Brooks 17). However, the article also makes the point that software progress is not necessarily slow due to development costs. Rather, the high speed of hardware development makes the progress of software appear slow in comparison to hardware’s rapid innovations (Brooks 11). Nonetheless, methods such as code replication, top-down design, and version-controlled storage of files all aid in decreasing the amount of time it takes to push out usable software. 
        </p>
        
        <p>
            One such example of decrease in development cost is illustrated in George V. Neville-Neil’s “Kode Vicious”. The article states that the best way to avoid ending up in the pits of cherry-picking is to be sure to periodically merge whatever code that a developer is working against. In other words, a developer should “have a merged and tested branch ready to go when it is time for [the developer’s] project to resynchronize with the head of the development tree” (Neville-Neil 33). A related idea is reflected by Google’s practices in Rachel Potvin and Josh Levenberg’s article, “Why Google Stores Billions of Lines of Code in a Single Repository”. Google implements the trunk-based development strategy in order to efficiently manage their large repository, thereby decreasing development costs. This method also helps to alleviate the difficulties associated with the merging of branches (as in “Kode Vicious”), but does so by attempting to altogether avoid the “painful merges that often occur when it is time to reconcile long-lived branches” (82). Rather than developing on the branches themselves, revisions (such as bug fixes) are developed on mainline and subsequently cherry-picked into the branch if necessary. Because of the extremely vast repository that Google works out of (which is not the case for all software developers), this method is especially beneficial, as it allows newly committed code to be immediately seen and used by all other Google developers (82). Although there exist additional benefits to this trunk-based approach, there also exists drawbacks, such as the added costs of developing automated testing and “pre-submit” infrastructure. 
        </p>
        
        <p>This reflects the common trend of trade-off analysis throughout the software development process in general, as reflected in “No Silver Bullet”. The article states that software development is the only technology where one can choose to gain from “either improved performance or in reduced costs”, suggesting that improved performance comes with a host of development costs while reduced costs comes with a decrease in software performance (Brooks 11). This is further illustrated by the fact that “Google invests significant effort in maintaining code health to address some issues related to codebase complexity and dependency management” thanks to its large repository (Potvin & Levenberg 86). Despite potential benefits of working out of smaller repositories, Google has determined that the benefits of maintaining its current working repository outweighs its current costs of maintenance or that of downsizing into a non-monolithic source repository. This example suggests part of the reasoning behind Brooks’ belief that no “silver bullets” are likely to appear anytime soon due to the very nature of software, such as its trade-offs, among other factors.</p>
        
        

    </body>



</html>
